from aiogram import Router
from aiogram import filters
from aiogram import  types
from aiogram import F,Bot
# from pyrogram import Client
from typing import Union, Dict, Optional, List
import random
from handlers.source.texts import start_message,help_text,about_text
from keyboards import inline
from functools import wraps
from aiogram.types import ReplyKeyboardRemove,FSInputFile, Message, User, Sticker, Contact, Document, PhotoSize
from urllib.parse import urlparse
import re
from states import Download,ID
from aiogram.enums import ContentType
from aiogram.fsm.context import FSMContext
# import SRC
from handlers.source import texts
from keyboards.inline import escape_keyboard



command_router = Router()

#@command_router.message(filters.Command("start"))
async def handler_start(s: types.Message) -> None:
    photo = FSInputFile("SRC/start2.jpg")
    await s.answer_photo(photo,caption=start_message(s.from_user),reply_markup=inline.start_keyboard, parse_mode="HTML")

@command_router.message(filters.Command("about"))
async def handler_about(a: types.Message) -> None:

    await a.answer(text=about_text,parse_mode="HTML")

@command_router.message(filters.Command("help"))
async def handler_about(h: types.Message) -> None:
    await h.answer(text=help_text, reply_markup=inline.help_keyboard, parse_mode="HTML")


TRIGGER_WORDS = ["–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ", "–¥–æ–±—Ä—ã–π –¥–µ–Ω—å", "–¥–æ–±—Ä–æ–µ —É—Ç—Ä–æ", "–¥–æ–±—Ä—ã–π –≤–µ—á–µ—Ä", "–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é", "—Ä–∞–¥ –≤–∞—Å –≤–∏–¥–µ—Ç—å", "–¥–æ–±—Ä–æ–≥–æ –∑–¥–æ—Ä–æ–≤—å—è", "–º–æ–µ –ø–æ—á—Ç–µ–Ω–∏–µ", "–ø—Ä–∏–≤–µ—Ç", "–ø—Ä–∏–≤–µ—Ç–∏–∫", "–∑–¥–æ—Ä–æ–≤–æ", "—Ö–∞–π", "—Ö—ç–ª–ª–æ—É", "—Å–∞–ª—é—Ç", "–∫–∞–∫ –¥–µ–ª–∞", "—á—ë –∫–∞–∫", "–¥–∞—Ä–æ–≤–∞", "–∑–¥–∞—Ä–æ–≤–∞", "—à–∞–ª–æ–º", "–ø—Ä–∏–≤–µ—Ç-–ø—Ä–∏–≤–µ—Ç", "–¥–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å", "–º–∏—Ä –≤–∞–º", "—Å–∞–ª–∞–º –∞–ª–µ–π–∫—É–º", "namaste", "–Ω–∏—Ö–∞–æ", "–º–∏—Ä –¥–æ–º—É —Ç–≤–æ–µ–º—É", "—á–µ–ª–æ–º –±—å—é", "–∑–¥—Ä–∞–≤–∏—è –∂–µ–ª–∞—é","–π–æ","–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π","hi","hello"]
@command_router.message(F.text.lower().in_(TRIGGER_WORDS))
async def handler_hi(text: types.Message) -> None:
    greetings = [
        "üëã –ü—Ä–∏–≤–µ—Ç! –ù–∞–ø–∏—à–∏ /start —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –º–æ–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏",
        "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ! ‚ú® –î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã –≤–≤–µ–¥–∏—Ç–µ /start",
        "–ü—Ä–∏–≤–µ—Ç-–ø—Ä–∏–≤–µ—Ç! üòä –í–≤–µ–¥–∏—Ç–µ /start –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π",
        "–†–∞–¥ –≤–∞—Å –≤–∏–¥–µ—Ç—å! üåü –ù–∞—á–Ω–∏—Ç–µ —Å –∫–æ–º–∞–Ω–¥—ã /start",
        "–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é! üé¨ –î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ—É–Ω–∫—Ü–∏—è–º –≤–≤–µ–¥–∏—Ç–µ /start",
        "–î–æ–±—Ä–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫! üí° –í–≤–µ–¥–∏—Ç–µ /start —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å",
        "–ü—Ä–∏–≤–µ—Ç! üöÄ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –º–µ–Ω—é",
        "–ó–¥–∞—Ä–æ–≤–∞! üòé –ù–∞–ø–∏—à–∏ /start —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å —á—Ç–æ —è —É–º–µ—é",
        "–•–∞–π! ‚ö° –î–ª—è —Å—Ç–∞—Ä—Ç–∞ —Ä–∞–±–æ—Ç—ã –≤–≤–µ–¥–∏ /start",
        "–î–æ–±—Ä—ã–π –¥–µ–Ω—å! üìå –ù–∞—á–Ω–∏—Ç–µ —Å –∫–æ–º–∞–Ω–¥—ã /start",
        "–ü—Ä–∏–≤–µ—Ç–∏–∫! üåà –í–≤–µ–¥–∏ /start –∏ —É–≤–∏–¥–∏—à—å –≤—Å–µ –º–æ–∏ —Ñ–∏—à–∫–∏",
        "–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é –≤–∞—Å! üíé –ö–æ–º–∞–Ω–¥–∞ /start –æ—Ç–∫—Ä–æ–µ—Ç –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        "üëã –î–∞—Ä–æ–≤–∞! –ñ–º–∏ /start –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏",
        "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π! üéØ –ù–∞–ø–∏—à–∏ /start —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É",
        "–ü—Ä–∏–≤–µ—Ç! üîç –£–∑–Ω–∞–π —á—Ç–æ —è —É–º–µ—é —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É /start"
    ]
    await text.answer(text=random.choice(greetings))

#@command_router.message(F.sticker)
async def handler_sticker(text: types.Message):
    stickers = ["CAACAgIAAxkBAAOzaEwXDe9UAdcrvLIr9ka4tEffeMIAAtRcAAL_l2BKM4F7hnvAn-E2BA","CAACAgIAAxkBAAO1aEwXEEHTnaw_rmqgNbgO6ALrdQ8AAiRaAAJaUGFKk-Tak4_7Tag2BA","CAACAgIAAxkBAAO3aEwXEp_tIKxaSUf94QKUyp7jYsAAApBZAALY1GFKurbeu8UknXE2BA","CAACAgIAAxkBAAO5aEwXEywNfBzU6eNBllgoa-eHy20AAp5YAAIvDGBKCYbdO1qw2zo2BA","CAACAgIAAxkBAAO7aEwXFHrWSB4JjfEoylOpY_XGSBgAAv1dAAL0KWBKsErb7eNo7FI2BA","CAACAgIAAxkBAAO9aEwXFfafmW3z-NmnUwjy6qf9PakAAnlZAAIqaGFKVbQ1ypMu0N42BA","CAACAgIAAxkBAAO_aEwXFlNwZTPPm_8t_1HfZON1tboAAnNaAAJwtWFKW8ChVXuZ3ko2BA","CAACAgIAAxkBAAPBaEwXGOZFYtZg8h3KLDY3wkMKdTwAArpaAALunmhKisyIr6qxwuc2BA","CAACAgIAAxkBAAPDaEwXGZgwT30aF-lkKySVMi9XK2AAAgZZAALjmWBKG5vAPipLfuo2BA","CAACAgIAAxkBAAPFaEwXGtwYuVI0zm23QCMu8-4z4sYAArReAAIdJWhK_oyTwfJtE7s2BA","CAACAgIAAxkBAAPHaEwXG4wJt2yhYe1aA_Prlu2fMegAAp1eAAJrYWBK5gE4XU8C02Q2BA","CAACAgIAAxkBAAPJaEwXG1vJX0t7e5_vwxUYbmrolaoAAjteAAIPwWBKVHlUVG-vuFU2BA","CAACAgIAAxkBAAPLaEwXHAvEQAcUTR-CAAG7kDGbQb3YAAK1WgACAQZgSk5Q2YTbVWboNgQ","CAACAgIAAxkBAAPNaEwXHfroK4aw99GIn_O_sXv9L-cAAgphAAK5RWBKft4qfrpg9RU2BA","CAACAgIAAxkBAAPPaEwXHzG0GotsQ67Z5X1-E-p0BcwAAidtAAOn8Eu99IZh1I0pTzYE","CAACAgIAAxkBAAPRaEwXIHrmuAABAqlTonDm3Xru0dtvAAIGaQACcbTxS2Z3MjBm1jMgNgQ","CAACAgIAAxkBAAPTaEwXIG0cELLv4H2ugctGCdSE1wkAAvNhAAK-HfBLfNUk3DQ-aVk2BA","CAACAgIAAxkBAAPVaEwXIRswTB24wZr0bu-1C3pOqcgAAnt-AAKUT_FLewydwp-iTLY2BA","CAACAgIAAxkBAAPXaEwXIoC_8ZTdMn18mlV77ctnycYAAihsAAJZ0_BL44baC4-Mghc2BA"]
    await text.answer_sticker(random.choice(stickers))

# @command_router.message(F.text == "MP3‚ñ∂Ô∏è",Download.wait_format)
# async def handler_mp3(text: types.Message,state: FSMContext):
#     text_mp3 = """
#     üîÑ <b>–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É—é –≤ MP3...</b>
#
#     –í–∞—à –∞—É–¥–∏–æ—Ñ–∞–π–ª –≥–æ—Ç–æ–≤–∏—Ç—Å—è! –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç 15-30 —Å–µ–∫—É–Ω–¥.
#
#     üìå <i>–ü–æ–∫–∞ –∂–¥–µ—Ç–µ:</i>
#     ‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ
#     ‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å –≤ —Å—Ç–∞–±–∏–ª—å–Ω–æ–º –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏
#
#     –°—Ç–∞—Ç—É—Å: <code>–ò–∑–≤–ª–µ–∫–∞–µ–º –∞—É–¥–∏–æ–¥–æ—Ä–æ–∂–∫—É...</code>
#     """
#     await text.answer(text=text_mp3,parse_mode="HTML",reply_markup=ReplyKeyboardRemove())
#     await state.set_state(Download.wait_file)

# @command_router.message(F.text == "MP4‚ñ∂Ô∏è",Download.wait_format)
# async def handler_mp4(text: types.Message,state: FSMContext):
#     text_mp4 = """
#         üîÑ <b>–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É—é –≤ MP4...</b>
#
#         –í–∞—à –≤–∏–¥–µ–æ—Ñ–∞–π–ª –≥–æ—Ç–æ–≤–∏—Ç—Å—è! –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç 15-30 —Å–µ–∫—É–Ω–¥.
#
#         üìå <i>–ü–æ–∫–∞ –∂–¥–µ—Ç–µ:</i>
#         ‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ
#         ‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å –≤ —Å—Ç–∞–±–∏–ª—å–Ω–æ–º –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏
#
#         –°—Ç–∞—Ç—É—Å: <code>–ò–∑–≤–ª–µ–∫–∞–µ–º –≤–∏–¥–µ–æ–¥–æ—Ä–æ–∂–∫—É...</code>
#         """
#     await text.answer(text=text_mp4,parse_mode="HTML",reply_markup=ReplyKeyboardRemove())
#     await state.set_state(Download.wait_file)



### –õ–û–ì–ò–ö–ê –ü–†–û–í–ï–†–ö–ò –í–ê–õ–ò–î–ù–û–°–¢–ò –°–°–´–õ–û–ö ###


def is_valid_url(url: str) -> bool:
    try:
        result = urlparse(url)
        return all([result.scheme in ('http', 'https'), result.netloc])
    except:
        return False

def is_supported_platform(url: str) -> bool:
    supported_domains = [
        'youtube.com',
        'youtu.be',
        'tiktok.com',
        'instagram.com',
        'vk.com',
        'dzen.ru'
        'soundcloud.com'
    ]
    domain = urlparse(url).netloc.lower()
    return any(d in domain for d in supported_domains)


@command_router.message(F.text,Download.wait_link)
async def handle_links(message: types.Message,state: FSMContext)->None:
    user_url = message.text.strip()

    if not is_valid_url(user_url):
        await message.answer(
            "‚ùå –≠—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ –≤–∞–ª–∏–¥–Ω—É—é —Å—Å—ã–ª–∫—É. –ü—Ä–∏–º–µ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞:\nhttps://youtube.com/watch?v=...")
        return

    if not is_supported_platform(user_url):
        await message.answer("‚ö†Ô∏è –≠—Ç–æ—Ç —Å–µ—Ä–≤–∏—Å –ø–æ–∫–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –†–∞–±–æ—Ç–∞–µ–º —Å:\nYouTube, TikTok, Soundcloud, VK, Instagram ")
        return

    # –ï–°–õ–ò –í–ê–©–ï –í–°–ï –ö–ê–ô–§
    valid_url = user_url #–ì–û–¢–û–í–ê–Ø –°–°–´–õ–ö–ê
    text_ans = """
üîé <b>–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å—Å—ã–ª–∫—É...</b>
    <b>–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç:</b>
    - MP3‚ñ∂Ô∏è
    - MP4‚ñ∂Ô∏è
    """
    await state.set_state(Download.wait_format)
    await message.answer(text=text_ans,parse_mode="HTML",reply_markup=inline.format_keyboard)


### –õ–û–ì–ò–ö–ê –î–õ–Ø –ü–û–õ–£–ß–ï–ù–ò–Ø ID ###

# async def find_user_by_username(username: str):
#     api_id = 12345  # –í–∞—à API ID (–ø–æ–ª—É—á–∏—Ç—å –Ω–∞ my.telegram.org)
#     api_hash = "–≤–∞—à_api_hash"  # –í–∞—à API Hash
#
#     async with Client("my_account", api_id, api_hash) as app:
#         try:
#             user = await app.get_users(username)
#             return user
#         except Exception as e:
#             return None






